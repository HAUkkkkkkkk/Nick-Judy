<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FOR ERYK ❤️</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020202; font-family: 'Segoe UI', sans-serif; cursor: pointer; }
        #canvas-container { width: 100%; height: 100vh; display: block; }
        #main-title {
            position: absolute; top: 30px; width: 100%; text-align: center;
            color: #fff; font-weight: 800; font-size: 50px; letter-spacing: 4px;
            text-shadow: 0 0 15px rgba(255,20,147,0.9);
            z-index: 100; pointer-events: none;
            font-family: 'Arial', sans-serif; text-transform: uppercase;
        }
        #start-guide {
            position: absolute; top: 50%; width: 100%; text-align: center;
            color: rgba(255,255,255,0.4); font-size: 16px;
            transform: translateY(-50%); pointer-events: none; animation: fade 2s infinite;
        }
        @keyframes fade { 0%,100% { opacity: 0.2; } 50% { opacity: 1; } }
    </style>
</head>
<body>
    <div id="main-title">FOR ERYK</div>
    <div id="start-guide">Chạm màn hình để bắt đầu ✨</div>
    <div id="canvas-container"></div>
    <video class="input_video" playsinline webkit-playsinline muted autoplay style="width:1px;height:1px;position:absolute;opacity:0;pointer-events:none;z-index:-1;"></video>

    <script>
        const MUSIC_URL = "./audio.mp3";
        let bgMusic = new Audio(MUSIC_URL); bgMusic.loop = true; bgMusic.volume = 1.0;
        const loader = new THREE.TextureLoader();
        const photoFiles = ['./image1.jpeg', './image2.jpeg', './image3.jpeg', './image4.jpeg', './image5.jpeg'];
        const photoTextures = []; photoFiles.forEach((f, i) => photoTextures[i] = loader.load(f));
        const nickImg = new Image(); nickImg.src = './nick.png';
        const judyImg = new Image(); judyImg.src = './judy.png';
        const carrotImg = new Image(); carrotImg.src = './carrot.png';

        function createDotTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            // Vẽ chấm tròn mềm (Soft dot)
            const grd = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grd.addColorStop(0, "rgba(255,255,255,1)");
            grd.addColorStop(0.5, "rgba(255,255,255,0.8)"); 
            grd.addColorStop(1, "rgba(255,255,255,0)");
            ctx.fillStyle = grd; ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(canvas);
        }
        const particleTexture = createDotTexture();
        const heartTexture = loader.load('https://threejs.org/examples/textures/sprites/heart.png'); // Dùng texture online cho tim đẹp hơn hoặc tự vẽ

        // TĂNG SỐ LƯỢNG HẠT LÊN RẤT CAO ĐỂ ẢNH RÕ NÉT
        const CONFIG = { 
            particleCount: 25000, 
            heartCount: 150,
            density: 2 // Quét kỹ từng 2 pixel (Số càng nhỏ ảnh càng nét)
        };
        
        let scene, camera, renderer, mainParticles, heartParticles;
        let photoMeshes = []; let state = 'DUO'; let handX = 0.5;
        let targetPositions = { duo: null, carrot: null };
        let targetColors = { duo: null, carrot: null };
        let isStarted = false;

        function init3D() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020202, 0.002);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = (window.innerWidth < 768) ? 190 : 140; 
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            createPhotos(); createFloatingHearts();

            Promise.all([
                // QUÉT ẢNH VỚI ĐỘ PHÂN GIẢI CAO (Density thấp = Nét)
                imageToPoints(nickImg, -35, 0.9, CONFIG.density),   
                imageToPoints(judyImg, 35, 0.75, CONFIG.density),    
                imageToPoints(carrotImg, 0, 0.8, 3) // Cà rốt thưa hơn xíu cho nghệ thuật
            ]).then(results => {
                const [nickData, judyData, carrotData] = results;
                
                // Gộp Nick & Judy
                const duoPoints = [...nickData.points, ...judyData.points];
                const duoCols = [...nickData.colors, ...judyData.colors];
                
                targetPositions.duo = new Float32Array(CONFIG.particleCount * 3);
                targetColors.duo = new Float32Array(CONFIG.particleCount * 3);
                targetPositions.carrot = new Float32Array(CONFIG.particleCount * 3);
                targetColors.carrot = new Float32Array(CONFIG.particleCount * 3);

                fillBuffer(targetPositions.duo, duoPoints); fillBuffer(targetColors.duo, duoCols);
                fillBuffer(targetPositions.carrot, carrotData.points); fillBuffer(targetColors.carrot, carrotData.colors);

                createMainParticleSystem(); animate();
            });
        }

        function fillBuffer(buffer, data) { 
            if (!data || data.length === 0) {
                // Nếu không có dữ liệu, ẩn hạt đi
                for (let i=0; i<buffer.length; i++) buffer[i] = 9999; 
                return;
            }
            // Điền dữ liệu, nếu thiếu thì lặp lại nhưng thêm nhiễu để không bị trùng vị trí
            for (let i = 0; i < buffer.length; i++) {
                buffer[i] = data[i % data.length];
                // Nếu lặp lại (vượt quá độ dài gốc), thêm chút nhiễu nhẹ
                if (i >= data.length) buffer[i] += (Math.random()-0.5) * 1.0;
            }
        }

        function imageToPoints(img, offsetX, scale, density) {
            return new Promise(resolve => {
                const run = () => {
                    const canvas = document.createElement('canvas');
                    const w = 220; // Canvas lớn để lấy chi tiết
                    const h = w * (img.height / img.width);
                    canvas.width = w; canvas.height = h;
                    const ctx = canvas.getContext('2d'); ctx.drawImage(img, 0, 0, w, h);
                    
                    if (img.width === 0) { resolve({points:[], colors:[]}); return; }

                    const data = ctx.getImageData(0, 0, w, h).data;
                    const points = [], colors = [];
                    
                    for(let y=0; y<h; y+=density) {
                        for(let x=0; x<w; x+=density) {
                            const i = (y*w + x) * 4;
                            // Ngưỡng alpha thấp (20) để lấy cả các chi tiết mờ như váy/lông
                            if(data[i+3] > 20) { 
                                points.push((x - w/2) * scale + offsetX, -(y - h/2) * scale, 0);
                                colors.push(data[i]/255, data[i+1]/255, data[i+2]/255);
                            }
                        }
                    }
                    resolve({ points, colors });
                };
                if(img.complete && img.naturalWidth !== 0) run(); 
                else { img.onload = run; img.onerror = () => resolve({points:[], colors:[]}); }
            });
        }

        function createMainParticleSystem() {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(CONFIG.particleCount * 3);
            const col = new Float32Array(CONFIG.particleCount * 3);
            // Khởi tạo vị trí ẩn
            for(let i=0; i<pos.length; i++) pos[i] = (Math.random()-0.5)*500; 
            
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
            
            // KÍCH THƯỚC HẠT (1.5) - Đủ to để rõ, đủ nhỏ để mịn
            const mat = new THREE.PointsMaterial({
                size: 1.5, map: particleTexture, vertexColors: true, 
                transparent: true, opacity: 1.0, // Độ rõ 100%
                depthWrite: false, blending: THREE.AdditiveBlending
            });
            mainParticles = new THREE.Points(geo, mat); scene.add(mainParticles);
        }

        function createFloatingHearts() {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(CONFIG.heartCount * 3);
            for(let i=0; i<pos.length; i+=3) {
                pos[i] = (Math.random()-0.5)*300; pos[i+1] = Math.random()*200 - 100; pos[i+2] = (Math.random()-0.5)*150;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({
                size: 4.0, color: 0xff1493, map: particleTexture,
                transparent: true, opacity: 0.6, depthWrite: false, blending: THREE.AdditiveBlending
            });
            heartParticles = new THREE.Points(geo, mat); scene.add(heartParticles);
        }

        function createPhotos() {
            const geo = new THREE.PlaneGeometry(14, 16); const borderGeo = new THREE.PlaneGeometry(15.5, 18);
            const borderMat = new THREE.MeshBasicMaterial({color: 0xffffff}); 
            for(let i=0; i<5; i++) {
                const mat = new THREE.MeshBasicMaterial({ map: photoTextures[i], side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geo, mat); 
                const border = new THREE.Mesh(borderGeo, borderMat); border.position.z = -0.1; border.position.y = -0.5;
                mesh.add(border); mesh.visible = false; scene.add(mesh); photoMeshes.push(mesh);
            }
        }

        function updateMainParticles(speed) {
            if(!mainParticles || !targetPositions.duo) return;
            const positions = mainParticles.geometry.attributes.position.array;
            const colors = mainParticles.geometry.attributes.color.array;
            let targetPos, targetCol;
            
            if (state === 'CARROT') { 
                targetPos = targetPositions.carrot; targetCol = targetColors.carrot; mainParticles.visible = true; 
            } else if (state === 'FOX') { 
                mainParticles.visible = false; return; 
            } else { 
                targetPos = targetPositions.duo; targetCol = targetColors.duo; mainParticles.visible = true; 
            }

            for(let i=0; i<positions.length; i++) {
                positions[i] += (targetPos[i] - positions[i]) * speed;
                colors[i] += (targetCol[i] - colors[i]) * speed;
            }
            mainParticles.geometry.attributes.position.needsUpdate = true;
            mainParticles.geometry.attributes.color.needsUpdate = true;
            // ĐỨNG YÊN (KHÔNG XOAY)
            mainParticles.rotation.y = 0; mainParticles.rotation.x = 0;
        }

        function updatePhotos() {
            if (state === 'FOX') { 
                photoMeshes.forEach((mesh, i) => {
                    mesh.visible = true;
                    // Ảnh bay theo tay
                    const baseAngle = -Math.PI/2 + (i-2)*0.35; const radius = 65;
                    const handTilt = (handX - 0.5) * 1.5; const finalAngle = baseAngle + handTilt;
                    const targetX = Math.sin(finalAngle) * radius; const targetZ = Math.cos(finalAngle) * radius - 40; const targetY = Math.cos(finalAngle) * 10 - 5;
                    mesh.position.lerp(new THREE.Vector3(targetX, targetY, targetZ), 0.08);
                    mesh.lookAt(camera.position); mesh.rotation.z = (i-2)*-0.15 + (handX-0.5)*0.5; 
                });
            } else { photoMeshes.forEach(m => { m.visible = false; }); }
        }

        function animate() {
            requestAnimationFrame(animate); updateMainParticles(0.1); updatePhotos();
            const hPos = heartParticles.geometry.attributes.position.array;
            for(let i=1; i<hPos.length; i+=3) { hPos[i] += 0.2; if(hPos[i] > 100) hPos[i] = -100; }
            heartParticles.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        function startSystem() {
            if (isStarted) return; isStarted = true;
            document.getElementById('start-guide').style.display = 'none'; 
            bgMusic.play().catch(e => console.log(e));
            init3D();
            const video = document.getElementsByClassName('input_video')[0];
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults(results => {
                if(results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0]; handX = lm[9].x; 
                    const tips = [8,12,16,20]; const wrist = lm[0];
                    let openDist = 0; tips.forEach(i => openDist += Math.hypot(lm[i].x-wrist.x, lm[i].y-wrist.y));
                    const pinchDist = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);
                    if (pinchDist < 0.06) state = 'FOX'; else if (openDist/4 > 0.25) state = 'CARROT'; else state = 'DUO';                        
                } else { state = 'DUO'; }
            });
            const cameraUtils = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 320, height: 240 });
            cameraUtils.start();
        }
        document.body.addEventListener('click', startSystem, { once: true });
        document.body.addEventListener('touchstart', startSystem, { once: true });
        window.addEventListener('resize', () => { if(camera) { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); } });
    </script>
</body>
</html>