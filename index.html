<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zootopia Particle Magic ‚ú®</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { 
            margin: 0; overflow: hidden; 
            background: radial-gradient(circle at center, #1a0b2e 0%, #000000 100%);
            font-family: 'Segoe UI', sans-serif; 
        }
        #canvas-container { width: 100%; height: 100vh; display: block; }
        #ui-layer {
            position: absolute; bottom: 30px; width: 100%;
            text-align: center; pointer-events: none; z-index: 100;
        }
        .guide { 
            color: #fff; font-weight: bold; font-size: 14px; margin-bottom: 20px; 
            text-shadow: 0 0 5px #ff4500;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 20px; border-radius: 30px; display: inline-block;
            backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.2);
        }
        button {
            pointer-events: auto; cursor: pointer;
            background: linear-gradient(to right, #ff8c00, #ff0080);
            color: #fff; border: none; padding: 15px 40px; border-radius: 50px; 
            font-weight: 800; font-size: 16px;
            box-shadow: 0 0 20px rgba(255, 69, 0, 0.6);
            animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }
        #camera-preview {
            position: absolute; top: 15px; right: 15px; width: 100px; height: 75px;
            border: 2px solid #ff8c00; transform: scaleX(-1); opacity: 0.7; border-radius: 10px;
        }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div class="guide">
            üñê <b>X√≤e:</b> B√∫t C√† r·ªët &nbsp;|&nbsp; ü´∂ <b>Ch·ª•m:</b> H√≥a C√°o &nbsp;|&nbsp; ‚úä <b>N·∫Øm:</b> H·ªôi ng·ªô (H·∫°t x·∫øp h√¨nh)
        </div>
        <br>
        <button id="btnStart" onclick="startSystem()">B·∫ÆT ƒê·∫¶U PHI V·ª§ ü¶äüê∞</button>
    </div>
    <div id="canvas-container"></div>
    <video class="input_video" playsinline webkit-playsinline muted autoplay style="width:1px;height:1px;position:absolute;opacity:0;pointer-events:none;z-index:-1;"></video>
    <canvas id="camera-preview"></canvas>

    <script>
        const MUSIC_URL = "./audio.mp3";
        let bgMusic = new Audio(MUSIC_URL); bgMusic.loop = true; bgMusic.volume = 1.0;

        const loader = new THREE.TextureLoader();
        const photoFiles = ['./image1.jpeg', './image2.jpeg', './image3.jpeg', './image4.jpeg', './image5.jpeg'];
        const photoTextures = []; photoFiles.forEach((f, i) => photoTextures[i] = loader.load(f));

        // Texture cho h·∫°t (ch·∫•m tr√≤n m·ªÅm)
        function createDotTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grd = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grd.addColorStop(0, "rgba(255,255,255,1)"); 
            grd.addColorStop(1, "rgba(255,255,255,0)");
            ctx.fillStyle = grd; ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(canvas);
        }
        const particleTexture = createDotTexture();

        // C·∫§U H√åNH
        const CONFIG = { 
            density: 8, // ƒê·ªô ph√¢n gi·∫£i qu√©t ·∫£nh (c√†ng nh·ªè c√†ng n√©t nh∆∞ng n·∫∑ng)
            orbitRadius: 55,
            foxColor: new THREE.Color('#FF4500'),
            carrotOrange: new THREE.Color('#FFA500'),
            carrotGreen: new THREE.Color('#32CD32')
        };

        let scene, camera, renderer;
        let particles; // H·ªá th·ªëng h·∫°t ch√≠nh
        let photoMeshes = [], titleMesh;
        let state = 'DUO'; let handX = 0.5;

        // L∆∞u tr·ªØ d·ªØ li·ªáu v·ªã tr√≠ c√°c h√¨nh d·∫°ng
        let targetPositions = { duo: [], fox: [], carrot: [] };
        let originalColors = []; // M√†u g·ªëc c·ªßa ·∫£nh (ƒë·ªÉ tr·∫£ v·ªÅ khi ·ªü tr·∫°ng th√°i Duo)

        function init3D() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = (window.innerWidth < 768) ? 160 : 120;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            createPhotos();
            createTitle();
            
            // T·∫£i ·∫£nh v√† t·∫°o h·∫°t
            loadImagesAndCreateParticles();
            
            animate();
        }

        // --- H√ÄM MAGIC: QU√âT ·∫¢NH T·∫†O H·∫†T ---
        function imageToPoints(imgUrl, offsetX, scale, isNick) {
            return new Promise(resolve => {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = imgUrl;
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    // Gi·∫£m k√≠ch th∆∞·ªõc ·∫£nh ƒë·ªÉ l·∫•y m·∫´u h·∫°t
                    const w = 100; 
                    const h = w * (img.height / img.width);
                    canvas.width = w; canvas.height = h;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, w, h);
                    const data = ctx.getImageData(0, 0, w, h).data;
                    
                    const points = [];
                    const colors = [];

                    for(let y=0; y<h; y++) {
                        for(let x=0; x<w; x++) {
                            const i = (y*w + x) * 4;
                            const alpha = data[i+3];
                            if(alpha > 128) { // Ch·ªâ l·∫•y ƒëi·ªÉm ·∫£nh kh√¥ng trong su·ªët
                                // Chuy·ªÉn ƒë·ªïi t·ªça ƒë·ªô 2D sang 3D
                                const pX = (x - w/2) * scale + offsetX;
                                const pY = -(y - h/2) * scale; // ƒê·∫£o ng∆∞·ª£c Y
                                const pZ = 0;
                                points.push(pX, pY, pZ);
                                // L∆∞u m√†u g·ªëc
                                colors.push(data[i]/255, data[i+1]/255, data[i+2]/255);
                            }
                        }
                    }
                    resolve({ points, colors });
                };
            });
        }

        async function loadImagesAndCreateParticles() {
            // Qu√©t ·∫£nh Nick v√† Judy
            const nickData = await imageToPoints('./nick.png', -25, 0.8, true);
            const judyData = await imageToPoints('./judy.png', 25, 0.7, false); // Judy nh·ªè h∆°n x√≠u

            // G·ªôp d·ªØ li·ªáu 2 nh√¢n v·∫≠t
            const allPoints = [...nickData.points, ...judyData.points];
            originalColors = [...nickData.colors, ...judyData.colors];
            const totalParticles = allPoints.length / 3;

            // T·∫°o c√°c v·ªã tr√≠ ƒë√≠ch cho c√°c tr·∫°ng th√°i kh√°c
            generateAbstractShapes(totalParticles);

            // L∆∞u v·ªã tr√≠ DUO (h√¨nh nh√¢n v·∫≠t)
            targetPositions.duo = new Float32Array(allPoints);

            // T·∫†O H·ªÜ TH·ªêNG H·∫†T THREE.JS
            const geo = new THREE.BufferGeometry();
            // V·ªã tr√≠ b·∫Øt ƒë·∫ßu ng·∫´u nhi√™n
            const initialPos = new Float32Array(totalParticles * 3);
            for(let i=0; i<totalParticles*3; i++) initialPos[i] = (Math.random()-0.5)*200;
            
            geo.setAttribute('position', new THREE.BufferAttribute(initialPos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(originalColors), 3));

            const mat = new THREE.PointsMaterial({
                size: 1.8, map: particleTexture,
                vertexColors: true, transparent: true, opacity: 0.9,
                depthWrite: false, blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geo, mat);
            scene.add(particles);
        }

        function generateAbstractShapes(count) {
            const pFox = [], pCarrot = [];
            for(let i=0; i<count; i++) {
                // --- FOX (C√°o) ---
                const rFox = Math.random();
                if(rFox < 0.3) { // ƒê·∫ßu
                     const y = 30 + Math.random()*20;
                     const w = (50-y)*1.5;
                     pFox.push((Math.random()-0.5)*w, y, (Math.random()-0.5)*10);
                } else if (rFox < 0.7) { // Th√¢n
                    pFox.push((Math.random()-0.5)*25, (Math.random()-0.5)*30, (Math.random()-0.5)*15);
                } else { // ƒêu√¥i
                     const t = Math.random()*Math.PI;
                     pFox.push((Math.random()-0.5)*15, Math.sin(t)*20 - 20, -Math.cos(t)*20 - 10);
                }

                // --- CARROT (C√† r·ªët) ---
                const h = Math.random() * 90; 
                const y = h - 45;
                if (h > 75) { // L√°
                    pCarrot.push((Math.random()-0.5)*25, y, (Math.random()-0.5)*25);
                } else { // C·ªß
                    const r = 12 * (1 - h/80) + 1;
                    const theta = Math.random() * Math.PI * 2;
                    pCarrot.push(r * Math.cos(theta), y, r * Math.sin(theta));
                }
            }
            targetPositions.fox = new Float32Array(pFox);
            targetPositions.carrot = new Float32Array(pCarrot);
        }

        function createPhotos() {
            const geo = new THREE.PlaneGeometry(10, 10); 
            const borderGeo = new THREE.PlaneGeometry(11, 11);
            const borderMat = new THREE.MeshBasicMaterial({color: 0xffd700});

            for(let i=0; i<5; i++) {
                const mat = new THREE.MeshBasicMaterial({ map: photoTextures[i], side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geo, mat);
                const border = new THREE.Mesh(borderGeo, borderMat); border.position.z = -0.1;
                mesh.add(border); mesh.visible = false;
                scene.add(mesh); photoMeshes.push(mesh);
            }
        }

        function createTitle() {
            const canvas = document.createElement('canvas'); canvas.width = 1024; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 80px "Segoe UI"'; ctx.fillStyle = '#fff'; ctx.textAlign = 'center';
            ctx.shadowColor = "#FF4500"; ctx.shadowBlur = 20; 
            ctx.fillText("ZOOTOPIA MISSION", 512, 150);
            const tex = new THREE.CanvasTexture(canvas);
            titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(50, 12), new THREE.MeshBasicMaterial({map:tex, transparent:true}));
            titleMesh.position.set(0, 60, 0);
            scene.add(titleMesh);
        }

        function updateParticles(speed, time) {
            if(!particles) return; // ƒê·ª£i load xong

            const positions = particles.geometry.attributes.position.array;
            const colors = particles.geometry.attributes.color.array;
            
            // X√°c ƒë·ªãnh ƒë√≠ch ƒë·∫øn d·ª±a tr√™n tr·∫°ng th√°i
            let targetArr;
            if(state === 'DUO') targetArr = targetPositions.duo;
            else if(state === 'FOX') targetArr = targetPositions.fox;
            else targetArr = targetPositions.carrot;

            if(!targetArr || targetArr.length === 0) return;

            // DI CHUY·ªÇN H·∫†T
            for(let i=0; i<positions.length; i++) {
                // Lerp (n·ªôi suy) ƒë·ªÉ di chuy·ªÉn m∆∞·ª£t m√†
                positions[i] += (targetArr[i] - positions[i]) * speed;
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // ƒê·ªîI M√ÄU H·∫†T
            const count = positions.length / 3;
            for(let i=0; i<count; i++) {
                const idx = i*3;
                if(state === 'DUO') {
                    // Tr·∫£ v·ªÅ m√†u g·ªëc c·ªßa ·∫£nh (t·ª´ t·ª´)
                    colors[idx] += (originalColors[idx] - colors[idx]) * 0.05;
                    colors[idx+1] += (originalColors[idx+1] - colors[idx+1]) * 0.05;
                    colors[idx+2] += (originalColors[idx+2] - colors[idx+2]) * 0.05;
                } else if (state === 'FOX') {
                    // H√≥a cam
                    colors[idx] += (CONFIG.foxColor.r - colors[idx]) * 0.05;
                    colors[idx+1] += (CONFIG.foxColor.g - colors[idx+1]) * 0.05;
                    colors[idx+2] += (CONFIG.foxColor.b - colors[idx+2]) * 0.05;
                } else {
                    // C√† r·ªët (Xanh l√° ·ªü tr√™n, Cam ·ªü d∆∞·ªõi)
                    const y = positions[idx+1];
                    let targetC = (y > 30) ? CONFIG.carrotGreen : CONFIG.carrotOrange;
                    colors[idx] += (targetC.r - colors[idx]) * 0.05;
                    colors[idx+1] += (targetC.g - colors[idx+1]) * 0.05;
                    colors[idx+2] += (targetC.b - colors[idx+2]) * 0.05;
                }
            }
            particles.geometry.attributes.color.needsUpdate = true;

            // Xoay nh·∫π
            if(state === 'DUO') particles.rotation.y = Math.sin(time*0.5) * 0.1;
            else particles.rotation.y += 0.01;
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            
            updateParticles(0.08, time);

            if (state === 'DUO') {
                titleMesh.visible = true;
                // ·∫¢nh bay xung quanh
                const angleStep = (Math.PI * 2) / 5;
                photoMeshes.forEach((mesh, i) => {
                    mesh.visible = true;
                    const angle = time * 0.3 + i * angleStep;
                    const r = CONFIG.orbitRadius;
                    mesh.position.lerp(new THREE.Vector3(Math.sin(angle)*r, Math.sin(time+i)*5, Math.cos(angle)*r), 0.1);
                    mesh.lookAt(camera.position); mesh.scale.set(1,1,1);
                });
            } else {
                titleMesh.visible = false;
                photoMeshes.forEach(m => { m.visible = false; m.scale.set(0,0,0); });
            }

            renderer.render(scene, camera);
        }

        function startSystem() {
            document.getElementById('btnStart').style.display = 'none';
            bgMusic.play().catch(e => console.log(e));
            init3D();

            const video = document.getElementsByClassName('input_video')[0];
            const canvas = document.getElementById('camera-preview');
            const ctx = canvas.getContext('2d');
            
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

            hands.onResults(results => {
                ctx.clearRect(0,0,100,75); ctx.drawImage(results.image, 0, 0, 100, 75);
                if(results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    handX = lm[9].x; 
                    const tips = [8,12,16,20]; const wrist = lm[0];
                    let openDist = 0; tips.forEach(i => openDist += Math.hypot(lm[i].x-wrist.x, lm[i].y-wrist.y));
                    const pinchDist = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);

                    if (pinchDist < 0.06) state = 'FOX'; 
                    else if (openDist/4 > 0.3) state = 'CARROT'; 
                    else state = 'DUO'; 
                } else { state = 'DUO'; }
            });

            const cameraUtils = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 320, height: 240 });
            cameraUtils.start();
        }
        window.addEventListener('resize', () => { if(camera) { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); } });
    </script>
</body>
</html>