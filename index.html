<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FOR ERYK ❤️</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; cursor: pointer; }
        #canvas-container { width: 100%; height: 100vh; display: block; }
        
        /* ĐÃ SỬA TIÊU ĐỀ Ở ĐÂY */
        #main-title {
            position: absolute; top: 30px; width: 100%; text-align: center;
            color: #fff; font-weight: 800; font-size: 40px; letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(255,105,180,0.8), 0 0 20px rgba(255,105,180,0.4);
            z-index: 100; pointer-events: none;
        }

        #start-guide {
            position: absolute; top: 50%; width: 100%; text-align: center;
            color: rgba(255,255,255,0.6); font-size: 18px;
            transform: translateY(-50%); pointer-events: none;
            animation: fade 2s infinite;
        }
        @keyframes fade { 0%,100% { opacity: 0.4; } 50% { opacity: 1; } }
    </style>
</head>
<body>
    <div id="main-title">FOR ERYK</div>
    <div id="start-guide">Chạm vào màn hình để bắt đầu ✨</div>

    <div id="canvas-container"></div>
    <video class="input_video" playsinline webkit-playsinline muted autoplay style="width:1px;height:1px;position:absolute;opacity:0;pointer-events:none;z-index:-1;"></video>

    <script>
        const MUSIC_URL = "./audio.mp3";
        let bgMusic = new Audio(MUSIC_URL); bgMusic.loop = true; bgMusic.volume = 1.0;

        const loader = new THREE.TextureLoader();
        const photoFiles = ['./image1.jpeg', './image2.jpeg', './image3.jpeg', './image4.jpeg', './image5.jpeg'];
        const photoTextures = []; photoFiles.forEach((f, i) => photoTextures[i] = loader.load(f));
        
        // Tải ảnh để quét hạt
        const nickImg = new Image(); nickImg.src = './nick.png';
        const judyImg = new Image(); judyImg.src = './judy.png';
        const carrotImg = new Image(); carrotImg.src = './carrot.png';

        function createHeartTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = "#ff69b4"; ctx.beginPath();
            ctx.moveTo(32, 12);
            ctx.bezierCurveTo(32, 8, 28, 0, 16, 0); ctx.bezierCurveTo(0, 0, 0, 22, 0, 24);
            ctx.bezierCurveTo(0, 38, 16, 48, 32, 64);
            ctx.bezierCurveTo(48, 48, 64, 38, 64, 24); ctx.bezierCurveTo(64, 22, 64, 0, 48, 0);
            ctx.bezierCurveTo(36, 0, 32, 8, 32, 12); ctx.fill();
            const tex = new THREE.CanvasTexture(canvas); tex.needsUpdate = true; return tex;
        }
        const heartTexture = createHeartTexture();

        // Tăng lượng hạt lên để hình rõ nét hơn
        const CONFIG = { particleCount: 8000, heartCount: 200, orbitRadius: 60 };
        
        let scene, camera, renderer, mainParticles, heartParticles;
        let photoMeshes = [];
        let state = 'DUO'; let handX = 0.5;
        
        let targetPositions = { duo: null, carrot: null, fox: null };
        let targetColors = { duo: null, carrot: null, fox: null };
        let isStarted = false;

        function init3D() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.002);
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = (window.innerWidth < 768) ? 180 : 140;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            createPhotos(); createFloatingHearts();

            // --- PHẦN QUAN TRỌNG: XỬ LÝ ẢNH ---
            Promise.all([
                // Điều chỉnh tọa độ (offset) và tỷ lệ (scale) để Nick và Judy không bị chồng lấn
                imageToPoints(nickImg, -35, 0.8),   // Nick bên trái, to hơn chút
                imageToPoints(judyImg, 35, 0.7),    // Judy bên phải, nhỏ hơn chút
                imageToPoints(carrotImg, 0, 0.8),   // Cà rốt giữa
                imageToPoints(nickImg, 0, 1.1)      // Cáo to (khi chụm tay)
            ]).then(results => {
                const [nickData, judyData, carrotData, foxData] = results;
                
                // Gộp điểm của Nick và Judy lại
                const duoPoints = [...nickData.points, ...judyData.points];
                const duoCols = [...nickData.colors, ...judyData.colors];
                
                targetPositions.duo = new Float32Array(CONFIG.particleCount * 3);
                targetColors.duo = new Float32Array(CONFIG.particleCount * 3);
                targetPositions.carrot = new Float32Array(CONFIG.particleCount * 3);
                targetColors.carrot = new Float32Array(CONFIG.particleCount * 3);
                targetPositions.fox = new Float32Array(CONFIG.particleCount * 3);
                targetColors.fox = new Float32Array(CONFIG.particleCount * 3);

                // Điền dữ liệu vào bộ nhớ
                fillBuffer(targetPositions.duo, duoPoints); fillBuffer(targetColors.duo, duoCols);
                fillBuffer(targetPositions.carrot, carrotData.points); fillBuffer(targetColors.carrot, carrotData.colors);
                fillBuffer(targetPositions.fox, foxData.points); fillBuffer(targetColors.fox, foxData.colors);

                createMainParticleSystem(); animate();
            });
        }

        function fillBuffer(buffer, data) { 
            if (!data || data.length === 0) {
                for (let i=0; i<buffer.length; i++) buffer[i] = (Math.random()-0.5)*100; return;
            }
            // Lặp lại dữ liệu nếu số điểm ảnh ít hơn số hạt
            for (let i = 0; i < buffer.length; i++) buffer[i] = data[i % data.length]; 
        }

        function imageToPoints(img, offsetX, scale) {
            return new Promise(resolve => {
                const run = () => {
                    const canvas = document.createElement('canvas');
                    const w = 150; const h = w * (img.height / img.width);
                    canvas.width = w; canvas.height = h;
                    const ctx = canvas.getContext('2d'); ctx.drawImage(img, 0, 0, w, h);
                    if (img.width === 0) { resolve({points:[], colors:[]}); return; }
                    const data = ctx.getImageData(0, 0, w, h).data;
                    const points = [], colors = [];
                    for(let y=0; y<h; y++) {
                        for(let x=0; x<w; x++) {
                            const i = (y*w + x) * 4;
                            if(data[i+3] > 100) { // Lấy điểm không trong suốt
                                points.push((x - w/2) * scale + offsetX, -(y - h/2) * scale, 0);
                                colors.push(data[i]/255, data[i+1]/255, data[i+2]/255);
                            }
                        }
                    }
                    resolve({ points, colors });
                };
                // Đảm bảo ảnh đã tải xong mới xử lý
                if(img.complete && img.naturalWidth !== 0) run(); 
                else { img.onload = run; img.onerror = () => resolve({points:[], colors:[]}); }
            });
        }

        function createMainParticleSystem() {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(CONFIG.particleCount * 3);
            const col = new Float32Array(CONFIG.particleCount * 3);
            for(let i=0; i<pos.length; i++) pos[i] = (Math.random()-0.5)*300;
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
            // Hạt nhỏ mịn
            const mat = new THREE.PointsMaterial({
                size: 1.2, vertexColors: true, transparent: true, opacity: 0.9,
                depthWrite: false, blending: THREE.AdditiveBlending
            });
            mainParticles = new THREE.Points(geo, mat); scene.add(mainParticles);
        }

        function createFloatingHearts() {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(CONFIG.heartCount * 3);
            for(let i=0; i<pos.length; i+=3) {
                pos[i] = (Math.random()-0.5)*250; pos[i+1] = Math.random()*200 - 100; pos[i+2] = (Math.random()-0.5)*100;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({
                size: 4.0, map: heartTexture, color: 0xff69b4,
                transparent: true, opacity: 0.6, depthWrite: false, blending: THREE.AdditiveBlending
            });
            heartParticles = new THREE.Points(geo, mat); scene.add(heartParticles);
        }

        function createPhotos() {
            const geo = new THREE.PlaneGeometry(14, 16); const borderGeo = new THREE.PlaneGeometry(16, 18);
            const borderMat = new THREE.MeshBasicMaterial({color: 0xffffff}); 
            for(let i=0; i<5; i++) {
                const mat = new THREE.MeshBasicMaterial({ map: photoTextures[i], side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geo, mat); mesh.position.y = 1; 
                const border = new THREE.Mesh(borderGeo, borderMat); border.position.z = -0.05;
                mesh.add(border); mesh.visible = false; scene.add(mesh); photoMeshes.push(mesh);
            }
        }

        function updateMainParticles(speed) {
            if(!mainParticles || !targetPositions.duo) return;
            const positions = mainParticles.geometry.attributes.position.array;
            const colors = mainParticles.geometry.attributes.color.array;
            
            let targetPos, targetCol;
            if (state === 'CARROT') {
                targetPos = targetPositions.carrot; targetCol = targetColors.carrot;
            } else if (state === 'FOX') { 
                targetPos = targetPositions.fox; targetCol = targetColors.fox;
            } else { 
                targetPos = targetPositions.duo; targetCol = targetColors.duo;
            }

            for(let i=0; i<positions.length; i++) {
                positions[i] += (targetPos[i] - positions[i]) * speed;
                colors[i] += (targetCol[i] - colors[i]) * speed;
            }
            mainParticles.geometry.attributes.position.needsUpdate = true;
            mainParticles.geometry.attributes.color.needsUpdate = true;
            
            if(state === 'DUO') mainParticles.rotation.y += 0.002;
            else if(state === 'CARROT') mainParticles.rotation.y += 0.01;
        }

        function updateHearts(time) {
            const positions = heartParticles.geometry.attributes.position.array;
            for(let i=0; i<positions.length; i+=3) {
                positions[i+1] += Math.sin(time + i)*0.05 + 0.05; 
                if(positions[i+1] > 100) positions[i+1] = -100; 
            }
            heartParticles.geometry.attributes.position.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            const speed = 0.08; 
            updateMainParticles(speed); updateHearts(time);

            if (state === 'FOX') { // CHỤM TAY -> HIỆN ẢNH POLAROID
                photoMeshes.forEach((mesh, i) => {
                    mesh.visible = true;
                    const angle = -Math.PI/2 + (i-2)*0.3; const r = 70;
                    mesh.position.lerp(new THREE.Vector3(Math.sin(angle)*r, Math.cos(angle)*10 - 10, Math.cos(angle)*r - 30), 0.1);
                    mesh.lookAt(camera.position); mesh.rotation.z = (i-2)*-0.1; 
                });
            } else {
                photoMeshes.forEach(m => { m.visible = false; });
            }
            renderer.render(scene, camera);
        }

        function startSystem() {
            if (isStarted) return; isStarted = true;
            document.getElementById('start-guide').style.display = 'none'; 
            bgMusic.play().catch(e => console.log(e));
            init3D();

            const video = document.getElementsByClassName('input_video')[0];
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults(results => {
                if(results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0]; handX = lm[9].x; 
                    const tips = [8,12,16,20]; const wrist = lm[0];
                    let openDist = 0; tips.forEach(i => openDist += Math.hypot(lm[i].x-wrist.x, lm[i].y-wrist.y));
                    const pinchDist = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);
                    
                    if (pinchDist < 0.06) state = 'FOX';       
                    else if (openDist/4 > 0.3) state = 'CARROT'; 
                    else state = 'DUO';                        
                } else { state = 'DUO'; }
            });
            const cameraUtils = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 320, height: 240 });
            cameraUtils.start();
        }

        document.body.addEventListener('click', startSystem, { once: true });
        document.body.addEventListener('touchstart', startSystem, { once: true });
        window.addEventListener('resize', () => { if(camera) { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); } });
    </script>
</body>
</html>